// Command stagefreight-gen-banner generates a Go source file containing the
// StageFreight logo as an ANSI-escaped string constant. The output file uses
// only printable characters and Go escape sequences — no raw control bytes.
//
// Usage:
//
//	stagefreight-gen-banner --in src/assets/logo.png --out src/output/banner_art_gen.go
package main

import (
	"bytes"
	"crypto/sha256"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"unicode/utf8"
)

// chafa render flags — pinned for determinism.
var chafaFlags = []string{
	"-s", "34x17",
	"--symbols", "block",
	"--work", "9",
	"--colors", "256",
}

func main() {
	inPath := flag.String("in", "", "path to input PNG image")
	outPath := flag.String("out", "", "path to output Go source file")
	flag.Parse()

	if *inPath == "" || *outPath == "" {
		fatal("usage: stagefreight-gen-banner --in <image.png> --out <output.go>")
	}

	// Resolve and validate input.
	absIn, err := filepath.Abs(*inPath)
	if err != nil {
		fatal("resolve input path: %v", err)
	}
	if _, err := os.Stat(absIn); err != nil {
		fatal("input image not found: %s", absIn)
	}

	// Verify chafa is available.
	chafaBin, err := exec.LookPath("chafa")
	if err != nil {
		fatal("chafa not found in PATH; install chafa or run in CI")
	}

	// Compute input SHA-256.
	pngData, err := os.ReadFile(absIn)
	if err != nil {
		fatal("read input: %v", err)
	}
	inputHash := fmt.Sprintf("%x", sha256.Sum256(pngData))

	// Get chafa version for header stamp.
	chafaVersion := getChafaVersion(chafaBin)

	// Render PNG to ANSI art.
	art := renderChafa(chafaBin, absIn)

	// Sanitize.
	art = sanitize(art)

	// Build escaped Go lines.
	lines := splitAndStrip(art)
	if len(lines) == 0 {
		fatal("chafa produced no output")
	}

	// Generate Go source.
	src := buildGoSource(lines, *inPath, inputHash, chafaVersion)

	// Atomic write: temp file then rename.
	absOut, err := filepath.Abs(*outPath)
	if err != nil {
		fatal("resolve output path: %v", err)
	}
	tmp, err := os.CreateTemp(filepath.Dir(absOut), ".banner_art_gen_*.go")
	if err != nil {
		fatal("create temp file: %v", err)
	}
	tmpName := tmp.Name()
	if _, err := tmp.Write(src); err != nil {
		tmp.Close()
		os.Remove(tmpName)
		fatal("write temp file: %v", err)
	}
	tmp.Close()

	if err := os.Rename(tmpName, absOut); err != nil {
		os.Remove(tmpName)
		fatal("rename to output: %v", err)
	}

	// Self-check: verify no raw control bytes in the written file.
	selfCheck(absOut)

	fmt.Fprintf(os.Stderr, "stagefreight-gen-banner: wrote %s (sha256:%s chafa:%s)\n",
		*outPath, inputHash[:12], chafaVersion)
}

func getChafaVersion(bin string) string {
	out, err := exec.Command(bin, "--version").Output()
	if err != nil {
		return "unknown"
	}
	// First line is typically "Chafa version X.Y.Z"
	line := strings.SplitN(strings.TrimSpace(string(out)), "\n", 2)[0]
	return strings.TrimSpace(line)
}

func renderChafa(bin, imagePath string) string {
	args := append(chafaFlags, imagePath)
	cmd := exec.Command(bin, args...)
	cmd.Env = append(os.Environ(), "LC_ALL=C", "LANG=C")

	out, err := cmd.Output()
	if err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			fatal("chafa failed (exit %d): %s", exitErr.ExitCode(), string(exitErr.Stderr))
		}
		fatal("chafa failed: %v", err)
	}
	return string(out)
}

func sanitize(art string) string {
	// Strip cursor hide/show sequences.
	art = strings.ReplaceAll(art, "\x1b[?25l", "")
	art = strings.ReplaceAll(art, "\x1b[?25h", "")
	// Strip screen clear/home sequences.
	art = strings.ReplaceAll(art, "\x1b[2J", "")
	art = strings.ReplaceAll(art, "\x1b[H", "")
	// Normalize line endings.
	art = strings.ReplaceAll(art, "\r\n", "\n")
	art = strings.ReplaceAll(art, "\r", "\n")
	return art
}

// splitAndStrip splits art into lines and strips leading/trailing blank ANSI lines.
func splitAndStrip(art string) []string {
	art = strings.TrimRight(art, "\n")
	lines := strings.Split(art, "\n")

	// Strip leading blank lines.
	start := 0
	for start < len(lines) && isBlankAnsiLine(lines[start]) {
		start++
	}
	// Strip trailing blank lines.
	end := len(lines)
	for end > start && isBlankAnsiLine(lines[end-1]) {
		end--
	}
	return lines[start:end]
}

// isBlankAnsiLine reports whether a line is visually empty
// (contains only whitespace after stripping ANSI escape sequences).
func isBlankAnsiLine(s string) bool {
	inEsc := false
	for _, r := range s {
		if inEsc {
			if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') {
				inEsc = false
			}
			continue
		}
		if r == '\033' {
			inEsc = true
			continue
		}
		if r != ' ' && r != '\t' {
			return false
		}
	}
	return true
}

func buildGoSource(lines []string, sourcePath, inputHash, chafaVersion string) []byte {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by stagefreight-gen-banner; DO NOT EDIT.\n")
	buf.WriteString("//\n")
	fmt.Fprintf(&buf, "// source:  %s\n", sourcePath)
	fmt.Fprintf(&buf, "// sha256:  %s\n", inputHash)
	fmt.Fprintf(&buf, "// chafa:   %s\n", chafaVersion)
	fmt.Fprintf(&buf, "// flags:   %s\n", strings.Join(chafaFlags, " "))
	buf.WriteString("\n")
	buf.WriteString("//go:build banner_art\n")
	buf.WriteString("\n")
	buf.WriteString("package output\n")
	buf.WriteString("\n")
	buf.WriteString("const BannerArtANSI = \"\" +\n")

	for i, line := range lines {
		quoted := strconv.Quote(line)
		if i < len(lines)-1 {
			fmt.Fprintf(&buf, "\t%s + \"\\n\" +\n", quoted)
		} else {
			fmt.Fprintf(&buf, "\t%s\n", quoted)
		}
	}

	return buf.Bytes()
}

// selfCheck verifies the generated file contains no raw control bytes.
func selfCheck(path string) {
	data, err := os.ReadFile(path)
	if err != nil {
		fatal("self-check: read: %v", err)
	}

	// Check 1: No raw C0 control bytes (except newline) or DEL.
	for i, b := range data {
		if b == '\n' {
			continue
		}
		if b <= 0x1F || b == 0x7F {
			fatal("self-check failed: raw control byte 0x%02X at offset %d in %s", b, i, path)
		}
	}

	// Check 2: No unicode hazards in the art content.
	// Extract everything between the first `"` and last `"` of the const.
	content := string(data)
	checkUnicodeHazards(content)
}

// checkUnicodeHazards scans the generated Go source for dangerous Unicode characters
// that should never appear in banner art output.
func checkUnicodeHazards(src string) {
	// We check the raw Go source text. Since strconv.Quote escapes all
	// non-printable characters, any literal hazard char in the source would
	// mean something bypassed the escaping.
	for i := 0; i < len(src); {
		r, size := utf8.DecodeRuneInString(src[i:])

		// BiDi override/isolate characters.
		switch r {
		case '\u202A', '\u202B', '\u202C', '\u202D', '\u202E',
			'\u2066', '\u2067', '\u2068', '\u2069':
			fatal("self-check failed: BiDi character U+%04X at byte offset %d", r, i)
		}

		// Zero-width characters.
		switch r {
		case '\u200B', '\u200C', '\u200D', '\uFEFF':
			fatal("self-check failed: zero-width character U+%04X at byte offset %d", r, i)
		}

		// Tag characters.
		if r >= 0xE0001 && r <= 0xE007F {
			fatal("self-check failed: tag character U+%04X at byte offset %d", r, i)
		}

		i += size
	}
}

func fatal(format string, args ...any) {
	fmt.Fprintf(os.Stderr, "stagefreight-gen-banner: "+format+"\n", args...)
	os.Exit(1)
}
